name: Build Packages

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
  schedule:
    - cron: 0 0 * * *
  workflow_dispatch:
    inputs:
      create_snapshot:
        description: 'åˆ›å»ºå¸¦æ—¥æœŸçš„å¿«ç…§ Release'
        required: false
        type: boolean
        default: false
      force_rebuild:
        description: 'å¼ºåˆ¶é‡æ–°æ„å»ºçš„åŒ…ï¼ˆé€—å·åˆ†éš”ï¼Œå¦‚: package1,package2ï¼‰'
        required: false
        type: string
        default: ''
      log_level:
        description: 'æ—¥å¿—çº§åˆ« (DEBUG, INFO, WARN, ERROR)'
        required: false
        type: choice
        options:
          - INFO
          - DEBUG
          - WARN
          - ERROR
        default: 'INFO'

env:
  REPO_NAME: skorion

jobs:
  # ===========================================================================
  # Job 1: æ£€æµ‹æ›´æ–°å¹¶åˆ—å‡ºéœ€è¦æ„å»ºçš„åŒ…
  # ===========================================================================
  list-packages:
    name: Detect Updates
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
    outputs:
      aur-packages: ${{ steps.set-aur.outputs.matrix }}
      local-packages: ${{ steps.set-local.outputs.matrix }}
      all-packages: ${{ steps.set-all.outputs.matrix }}
      has-updates: ${{ steps.check-updates.outputs.has-updates }}
    steps:
      - uses: actions/checkout@v4
      
      # ç¼“å­˜ makepkg æºç ç›®å½•ï¼ŒåŠ é€Ÿç‰ˆæœ¬æ£€æµ‹ï¼ˆç‰¹åˆ«æ˜¯ mesa-git ç­‰å¤§å‹ä»“åº“ï¼‰
      - name: Cache makepkg sources for version detection
        uses: actions/cache@v4
        with:
          path: /tmp/makepkg-cache
          key: version-check-sources-${{ hashFiles('aur.conf', 'aur-pinned.conf') }}
          restore-keys: |
            version-check-sources-
      
      - name: Install dependencies
        run: |
          pacman -Syu --noconfirm
          # base-devel: åŒ…å« makepkg ç­‰æ„å»ºå·¥å…·
          # git, svn, mercurial, bzr: VCS å·¥å…·ï¼ˆpkgver() å‡½æ•°å¯èƒ½éœ€è¦ï¼‰
          # cargo, rust: Rust é¡¹ç›®çš„ pkgver() å¯èƒ½éœ€è¦
          # jq, curl, tar, findutils, meson: è„šæœ¬ä¾èµ–
          pacman -S --noconfirm base-devel git svn mercurial bzr cargo rust jq curl tar findutils sudo meson
      
      - name: Clean up stale locks from previous runs
        run: |
          echo "==> æ¸…ç†ä¹‹å‰å¯èƒ½é—ç•™çš„é”"
          
          LOCKS=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/git/matching-refs/locks/" \
            | jq -r '.[].ref // empty' 2>/dev/null || echo "")
          
          if [ -z "$LOCKS" ]; then
            echo "  âœ“ æ²¡æœ‰é—ç•™çš„é”"
          else
            echo "  å‘ç°é—ç•™çš„é”ï¼Œå¼€å§‹æ¸…ç†..."
            echo "$LOCKS" | while read ref; do
              if [ -n "$ref" ]; then
                echo "    åˆ é™¤: $ref"
                HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X DELETE \
                  -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/${{ github.repository }}/git/$ref")
                
                if [ "$HTTP_CODE" = "204" ]; then
                  echo "      âœ“ åˆ é™¤æˆåŠŸ"
                elif [ "$HTTP_CODE" = "404" ]; then
                  echo "      âš  å·²ä¸å­˜åœ¨"
                else
                  echo "      âš  åˆ é™¤å¤±è´¥ (HTTP $HTTP_CODE)"
                fi
                sleep 0.3
              fi
            done
            echo "  âœ“ æ¸…ç†å®Œæˆ"
          fi
      
      - name: Setup builder user
        run: |
          # åˆ›å»º builder ç”¨æˆ·ï¼ˆmakepkg ä¸å…è®¸ root è¿è¡Œï¼‰
          useradd -m -G wheel builder
          echo "builder ALL=(ALL) NOPASSWD: ALL" >> /etc/sudoers
          
          # ç»™äºˆå·¥ä½œç›®å½•æƒé™
          chown -R builder:builder $GITHUB_WORKSPACE
          
          # è®¾ç½® makepkg æºç ç¼“å­˜ç›®å½•æƒé™
          mkdir -p /tmp/makepkg-cache
          chown -R builder:builder /tmp/makepkg-cache
      
      - name: Check package updates
        id: check-updates
        env:
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
          FORCE_REBUILD: ${{ github.event.inputs.force_rebuild || '' }}
          LOG_LEVEL: ${{ github.event.inputs.log_level || 'INFO' }}
          SRCDEST: /tmp/makepkg-cache
        run: |
          # ä»¥ builder ç”¨æˆ·è¿è¡Œæ£€æŸ¥è„šæœ¬ï¼Œä¿ç•™ç¯å¢ƒå˜é‡
          sudo -u builder \
            REPO_OWNER="$REPO_OWNER" \
            REPO_NAME="$REPO_NAME" \
            FORCE_REBUILD="$FORCE_REBUILD" \
            LOG_LEVEL="$LOG_LEVEL" \
            SRCDEST="$SRCDEST" \
            bash scripts/check-updates.sh
      
      - name: List AUR packages to build
        id: set-aur
        run: |
          if [ -s updated-aur-packages.txt ]; then
            packages=$(cat updated-aur-packages.txt | jq -R -s -c 'split("\n")[:-1]')
          else
            packages="[]"
          fi
          echo "matrix=$packages" >> $GITHUB_OUTPUT
          echo "AUR packages to build: $packages"
      
      - name: List local packages to build
        id: set-local
        run: |
          if [ -s updated-local-packages.txt ]; then
            packages=$(cat updated-local-packages.txt | jq -R -s -c 'split("\n")[:-1]')
          else
            packages="[]"
          fi
          echo "matrix=$packages" >> $GITHUB_OUTPUT
          echo "Local packages to build: $packages"
      
      - name: Merge package lists
        id: set-all
        run: |
          # åˆå¹¶ AUR å’Œæœ¬åœ°åŒ…åˆ—è¡¨ï¼Œæ·»åŠ ç±»å‹æ ‡è®°
          aur_packages='${{ steps.set-aur.outputs.matrix }}'
          local_packages='${{ steps.set-local.outputs.matrix }}'
          
          # ä¸ºæ¯ä¸ªåŒ…æ·»åŠ ç±»å‹å­—æ®µï¼ˆä½¿ç”¨ -c å‹ç¼©æˆå•è¡Œï¼‰
          all_packages=$(jq -nc \
            --argjson aur "$aur_packages" \
            --argjson local "$local_packages" \
            '($aur | map({package: ., type: "aur"})) + ($local | map({package: ., type: "local"}))')
          
          echo "matrix=$all_packages" >> $GITHUB_OUTPUT
          echo "All packages to build: $(echo "$all_packages" | jq -c '.[0:3]')... (total: $(echo "$all_packages" | jq 'length'))"

  # ===========================================================================
  # Job 2: å¹¶è¡Œæ„å»ºæ‰€æœ‰åŒ…ï¼ˆAUR + æœ¬åœ°ï¼‰
  # ===========================================================================
  build-packages:
    needs: list-packages
    name: Build Packages
    runs-on: ubuntu-latest
    if: needs.list-packages.outputs.all-packages != '[]'
    strategy:
      fail-fast: false
      max-parallel: 20
      matrix:
        include: ${{ fromJson(needs.list-packages.outputs.all-packages) }}
    
    steps:
      - uses: actions/checkout@v4
      
      # æ¢å¤æ„å»ºç¼“å­˜ï¼ˆä¸æ£€æµ‹é˜¶æ®µå…±äº«ï¼‰
      - name: Restore makepkg sources cache for building
        uses: actions/cache/restore@v4
        with:
          path: /tmp/makepkg-cache
          key: version-check-sources-${{ hashFiles('aur.conf', 'aur-pinned.conf') }}
          restore-keys: |
            version-check-sources-
      
      # ç¡®ä¿ç¼“å­˜ç›®å½•å­˜åœ¨
      - name: Setup cache directory
        run: |
          mkdir -p /tmp/makepkg-cache
          chmod 777 /tmp/makepkg-cache
      
      - name: Check if package needs full cleanup
        id: check-cleanup
        run: |
          PACKAGE="${{ matrix.package }}"
          
          # Read full-cleanup-packages.conf if exists
          if [ -f "full-cleanup-packages.conf" ]; then
            # Remove comments and empty lines, then check if package is in the list
            if grep -v '^#' full-cleanup-packages.conf | grep -v '^[[:space:]]*$' | grep -Fxq "$PACKAGE"; then
              echo "needs_full_cleanup=true" >> $GITHUB_OUTPUT
              echo "âœ“ Package '$PACKAGE' needs full disk cleanup"
            else
              echo "needs_full_cleanup=false" >> $GITHUB_OUTPUT
              echo "âœ“ Package '$PACKAGE' uses standard cleanup"
            fi
          else
            # Default to standard cleanup if file doesn't exist
            echo "needs_full_cleanup=false" >> $GITHUB_OUTPUT
            echo "âš  full-cleanup-packages.conf not found, using standard cleanup"
          fi
      
      - name: Free Disk Space - standard
        if: steps.check-cleanup.outputs.needs_full_cleanup == 'false'
        uses: endersonmenezes/free-disk-space@v3
        with:
          remove_android: true
          remove_dotnet: true
          remove_haskell: true
          rm_cmd: "rmz"  # Use 'rmz' for faster deletion (default: 'rm')
          rmz_version: "3.1.1"  # Required when rm_cmd is 'rmz'
          testing: false

      - name: Free Disk Space - full
        if: steps.check-cleanup.outputs.needs_full_cleanup == 'true'
        uses: endersonmenezes/free-disk-space@v3
        with:
          remove_android: true
          remove_dotnet: true
          remove_haskell: true
          remove_tool_cache: true
          remove_swap: true
          remove_packages: "azure-cli google-cloud-cli microsoft-edge-stable google-chrome-stable firefox postgresql* temurin-* *llvm* mysql* dotnet-sdk-*"
          remove_packages_one_command: true
          remove_folders: "/usr/share/swift /usr/share/miniconda /usr/share/az* /usr/local/lib/node_modules /usr/local/share/chromium /usr/local/share/powershell /usr/local/julia /usr/local/aws-cli /usr/local/aws-sam-cli /usr/share/gradle"
          rm_cmd: "rm"  # Use 'rmz' for faster deletion (default: 'rm')
          rmz_version: "3.1.1"  # Required when rm_cmd is 'rmz'
          testing: false
      
      - name: Check build mode
        id: mode
        run: |
          if [ "${{ github.event_name }}" = "schedule" ] || [ "${{ github.event.inputs.create_snapshot }}" = "true" ]; then
            echo "snapshot=true" >> $GITHUB_OUTPUT
            echo "==> å¿«ç…§æ¨¡å¼"
          else
            echo "snapshot=false" >> $GITHUB_OUTPUT
            echo "==> å¢é‡æ¨¡å¼"
          fi
      
      - name: Build ${{ matrix.type }} package - ${{ matrix.package }}
        id: build
        run: |
          mkdir -p "$GITHUB_WORKSPACE/output"
          
          docker run --rm \
            -v "$GITHUB_WORKSPACE:/workspace" \
            -v "/tmp/makepkg-cache:/tmp/makepkg-cache" \
            -e SRCDEST=/tmp/makepkg-cache \
            -w /workspace \
            archlinux:latest \
            bash /workspace/scripts/build-in-container.sh "${{ matrix.package }}" "${{ matrix.type }}"
      
      # å¿«ç…§æ¨¡å¼ï¼šä¸Šä¼  artifactï¼ˆä¼ ç»Ÿæ–¹å¼ï¼‰
      - name: Upload package artifact (snapshot mode)
        if: success() && steps.mode.outputs.snapshot == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.type }}-${{ matrix.package }}
          path: output/*.pkg.tar.zst
          if-no-files-found: error
          retention-days: 1
      
      # å¢é‡æ¨¡å¼ï¼šå®æ—¶ä¸Šä¼ åˆ° latest release
      - name: Acquire database lock (incremental mode)
        id: lock
        if: success() && steps.mode.outputs.snapshot == 'false'
        continue-on-error: true
        run: |
          echo "==> å°è¯•è·å–æ•°æ®åº“é”"
          MAX_RETRIES=60
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            RESPONSE=$(curl -s -X POST \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/git/refs" \
              -d "{\"ref\": \"refs/locks/database\", \"sha\": \"${{ github.sha }}\"}")
            
            if echo "$RESPONSE" | jq -e '.object' >/dev/null 2>&1; then
              echo "âœ“ è·å–é”æˆåŠŸ"
              echo "locked=true" >> $GITHUB_OUTPUT
              exit 0
            elif echo "$RESPONSE" | grep -q "already exists"; then
              echo "é”è¢«å ç”¨ï¼Œç­‰å¾…ä¸­... ($((RETRY_COUNT+1))/$MAX_RETRIES)"
              sleep 5
              RETRY_COUNT=$((RETRY_COUNT+1))
            else
              echo "âš ï¸ API é”™è¯¯: $RESPONSE"
              echo "è·³è¿‡æ•°æ®åº“æ›´æ–°"
              echo "locked=false" >> $GITHUB_OUTPUT
              exit 0
            fi
          done
          
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "âš ï¸ è·å–é”è¶…æ—¶ï¼Œå°†è·³è¿‡æ•°æ®åº“æ›´æ–°"
            echo "åŒ…æ–‡ä»¶å·²ä¸Šä¼ ï¼Œæœ€ç»ˆä¼šç”± finalize ä»»åŠ¡ç»Ÿä¸€æ›´æ–°æ•°æ®åº“"
            echo "locked=false" >> $GITHUB_OUTPUT
            exit 0
          fi
      
      - name: Upload package to latest release (incremental mode)
        if: success() && steps.mode.outputs.snapshot == 'false'
        continue-on-error: true
        uses: softprops/action-gh-release@v1
        with:
          tag_name: latest
          files: output/*.pkg.tar.zst
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Download and update database (incremental mode)
        if: success() && steps.mode.outputs.snapshot == 'false' && steps.lock.outputs.locked == 'true'
        run: |
          docker run --rm \
            -v "$GITHUB_WORKSPACE:/workspace" \
            -w /workspace \
            archlinux:latest \
            bash /workspace/scripts/update-repo-database.sh "${{ github.repository }}"
      
      - name: Upload updated database (incremental mode)
        if: success() && steps.mode.outputs.snapshot == 'false' && steps.lock.outputs.locked == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: latest
          files: |
            skorion.db.tar.gz
            skorion.files.tar.gz
            skorion.db
            skorion.files
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Release database lock
        if: always() && steps.lock.outputs.locked == 'true'
        run: |
          echo "==> é‡Šæ”¾æ•°æ®åº“é”"
          
          HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X DELETE \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/git/refs/locks/database")
          
          if [ "$HTTP_CODE" = "204" ]; then
            echo "âœ“ é”é‡Šæ”¾æˆåŠŸ"
          elif [ "$HTTP_CODE" = "404" ]; then
            echo "âš  é”ä¸å­˜åœ¨ï¼ˆå¯èƒ½å·²è¢«å…¶ä»–ä»»åŠ¡é‡Šæ”¾ï¼‰"
          else
            echo "âš  é”é‡Šæ”¾å¤±è´¥ (HTTP $HTTP_CODE)ï¼Œä½†ä¸å½±å“æµç¨‹"
          fi

  # ===========================================================================
  # Job 3: å¿«ç…§æ¨¡å¼ - æ”¶é›†æ‰€æœ‰åŒ…å¹¶ç”Ÿæˆå®Œæ•´ä»“åº“æ•°æ®åº“
  # ===========================================================================
  generate-snapshot:
    needs: [list-packages, build-packages]
    name: Generate Snapshot Repository
    runs-on: ubuntu-latest
    if: |
      always() && 
      (github.event_name == 'schedule' || github.event.inputs.create_snapshot == 'true') &&
      needs.build-packages.result != 'cancelled'
    container:
      image: archlinux:latest
    outputs:
      should-publish: ${{ steps.verify-packages.outputs.should-continue }}
      is-snapshot: ${{ steps.check-mode.outputs.is-snapshot }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Install dependencies
        run: |
          pacman -Syu --noconfirm
          pacman -S --noconfirm pacman-contrib curl jq
      
      - name: Download new build artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: aur-*
          merge-multiple: true
          path: output/
        continue-on-error: true
      
      - name: Download local package artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: local-*
          merge-multiple: true
          path: output/
        continue-on-error: true
      
      - name: List new packages
        run: |
          echo "==> æ–°æ„å»ºçš„åŒ…:"
          ls -lh output/ || echo "  æ— æ–°åŒ…"
      
      - name: Check build mode
        id: check-mode
        env:
          CREATE_SNAPSHOT: ${{ github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && inputs.create_snapshot) }}
        run: |
          echo "is-snapshot=$CREATE_SNAPSHOT" >> $GITHUB_OUTPUT
          if [ "$CREATE_SNAPSHOT" = "true" ]; then
            echo "==> ğŸ—“ï¸  å¿«ç…§æ¨¡å¼ï¼šå°†åˆ›å»ºå®Œæ•´çš„åŒ…é›†åˆå¿«ç…§"
          else
            echo "==> ğŸ”„ å¢é‡æ¨¡å¼ï¼šä»…æ›´æ–°å˜æ›´çš„åŒ…"
          fi
      
      # æ­¥éª¤1ï¼šæ¸…ç† release ä¸­å·²å­˜åœ¨çš„é‡å¤ç‰ˆæœ¬ï¼ˆæ‰«ææ¨¡å¼ï¼‰
      - name: Step 1 - Clean duplicates in release (scan mode)
        if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && inputs.create_snapshot)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO_FULL: ${{ github.repository }}
          OUTPUT_DIR: /tmp/empty_for_scan
          RELEASE_TAG: latest
        run: |
          echo "==> æ­¥éª¤1: æ¸…ç† release ä¸­å·²æœ‰çš„é‡å¤ç‰ˆæœ¬ï¼ˆæ‰«ææ¨¡å¼ï¼‰"
          echo "    æ­¤æ­¥éª¤ç¡®ä¿ release è‡ªèº«æ²¡æœ‰é‡å¤åŒ…"
          mkdir -p "$OUTPUT_DIR"
          bash scripts/clean-old-assets.sh
      
      # æ­¥éª¤2ï¼šæ¸…ç†ä¸æœ¬æ¬¡æ„å»ºå†²çªçš„æ—§ç‰ˆæœ¬ï¼ˆæœ¬åœ°åŒ…æ¨¡å¼ï¼‰
      - name: Step 2 - Clean old versions conflicting with new builds (local mode)
        if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && inputs.create_snapshot)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO_FULL: ${{ github.repository }}
          OUTPUT_DIR: ./output
          RELEASE_TAG: latest
        run: |
          echo "==> æ­¥éª¤2: æ¸…ç† release ä¸­ä¸æœ¬æ¬¡æ–°æ„å»ºå†²çªçš„æ—§ç‰ˆæœ¬ï¼ˆåŸºäºæœ¬åœ°åŒ…æ¨¡å¼ï¼‰"
          echo "    æ­¤æ­¥éª¤åˆ é™¤ release ä¸­æ‰€æœ‰ä¸æœ¬æ¬¡æ–°æ„å»ºåŒ…åç›¸åŒçš„æ—§ç‰ˆæœ¬"
          bash scripts/clean-old-assets.sh
      
      # éªŒè¯æœ€ç»ˆç»“æœ
      - name: Verify no duplicates remain in release
        if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && inputs.create_snapshot)
        run: |
          echo "==> éªŒè¯æ¸…ç†ç»“æœ"
          DUPES=$(curl -s "https://api.github.com/repos/${{ github.repository }}/releases/tags/latest" | \
            jq -r '.assets[] | select(.name | endswith(".pkg.tar.zst")) | .name' | \
            sed 's/-[0-9].*\.pkg\.tar\.zst$//' | sort | uniq -d)
          
          if [ -n "$DUPES" ]; then
            echo "âŒ é”™è¯¯ï¼šä»ç„¶å­˜åœ¨é‡å¤çš„åŒ…ï¼š"
            echo "$DUPES"
            echo ""
            echo "è¿™ä¸åº”è¯¥å‘ç”Ÿã€‚å¯èƒ½çš„åŸå› ï¼š"
            echo "  1. æ¸…ç†è„šæœ¬æ‰§è¡Œå¤±è´¥"
            echo "  2. åœ¨æ¸…ç†æœŸé—´æœ‰å…¶ä»–ä»»åŠ¡ä¸Šä¼ äº†åŒ…"
            exit 1
          else
            echo "âœ“ éªŒè¯é€šè¿‡ï¼šrelease ä¸­æ— é‡å¤ç‰ˆæœ¬"
          fi
      
      - name: Download existing data from latest release
        id: download-existing
        env:
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
          CREATE_SNAPSHOT: ${{ github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && inputs.create_snapshot) }}
        run: |
          echo "==> ä¸‹è½½ latest Release ä¸­çš„ç°æœ‰æ•°æ®"
          
          # ç¡®ä¿ output ç›®å½•å­˜åœ¨
          mkdir -p output
          
          # è·å– latest release ä¿¡æ¯
          LATEST_JSON=$(curl -s "https://api.github.com/repos/${REPO_OWNER}/${REPO_NAME}/releases/tags/latest" || echo "{}")
          
          # æ£€æŸ¥æ˜¯å¦å­˜åœ¨
          if echo "$LATEST_JSON" | jq -e '.message == "Not Found"' > /dev/null 2>&1; then
            echo "==> é¦–æ¬¡æ„å»ºï¼Œæ— ç°æœ‰æ•°æ®"
            echo "has-existing-data=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # æ£€æŸ¥ assets æ˜¯å¦å­˜åœ¨ä¸”ä¸ä¸ºç©º
          assets_count=$(echo "$LATEST_JSON" | jq '.assets | length // 0')
          if [ "$assets_count" -eq 0 ]; then
            echo "==> latest release å­˜åœ¨ä½†æ²¡æœ‰ assetsï¼Œå¯èƒ½æ˜¯é¦–æ¬¡æ„å»º"
            echo "has-existing-data=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "has-existing-data=true" >> $GITHUB_OUTPUT
          
          if [ "$CREATE_SNAPSHOT" = "true" ]; then
            # åˆ›å»ºå¿«ç…§ï¼šä¸‹è½½æ‰€æœ‰åŒ…ï¼ˆéœ€è¦å®Œæ•´å‰¯æœ¬ï¼‰
            echo "==> å¿«ç…§æ¨¡å¼ï¼šä¸‹è½½æ‰€æœ‰åŒ…æ–‡ä»¶"
            echo "$LATEST_JSON" | jq -r '.assets[] | select(.name | endswith(".pkg.tar.zst")) | .browser_download_url' | while read url; do
              filename=$(basename "$url")
              
              # è·³è¿‡å·²å­˜åœ¨çš„åŒ…ï¼ˆæ–°æ„å»ºä¼˜å…ˆï¼‰
              if [ -f "output/$filename" ]; then
                echo "  è·³è¿‡ $filename (å·²æœ‰æ–°ç‰ˆæœ¬)"
                continue
              fi
              
              echo "  ä¸‹è½½ $filename"
              curl -sL "$url" -o "output/$filename"
            done
          else
            # æ—¥å¸¸æ›´æ–°ï¼šåªä¸‹è½½æ•°æ®åº“æ–‡ä»¶ï¼ˆå¢é‡æ›´æ–°ï¼‰
            echo "==> å¢é‡æ¨¡å¼ï¼šåªä¸‹è½½æ•°æ®åº“æ–‡ä»¶"
            echo "$LATEST_JSON" | jq -r '.assets[] | select(.name | test("\\.(db|files)")) | .browser_download_url' | while read url; do
              filename=$(basename "$url")
              echo "  ä¸‹è½½ $filename"
              curl -sL "$url" -o "output/$filename"
            done
            
          fi
          
          echo "==> å½“å‰æ–‡ä»¶åˆ—è¡¨:"
          ls -lh output/
      
      - name: Verify package files exist
        id: verify-packages
        env:
          HAS_EXISTING_DATA: ${{ steps.download-existing.outputs.has-existing-data }}
          HAS_NEW_BUILDS: ${{ needs.list-packages.outputs.all-packages != '[]' }}
          IS_SNAPSHOT: ${{ steps.check-mode.outputs.is-snapshot }}
        run: |
          pkg_count=$(ls output/*.pkg.tar.zst 2>/dev/null | wc -l)
          
          if [ "$pkg_count" -eq 0 ]; then
            # æƒ…å†µ 1: é¦–æ¬¡æ„å»ºä¸”æ— åŒ…æ›´æ–°ï¼ˆæ—¢æ— ç°æœ‰æ•°æ®ï¼Œä¹Ÿæ— æ–°æ„å»ºï¼‰
            if [ "$HAS_EXISTING_DATA" != "true" ] && [ "$HAS_NEW_BUILDS" != "true" ]; then
              echo "==> é¦–æ¬¡æ„å»ºä¸”æ— åŒ…æ›´æ–°ï¼Œè·³è¿‡åç»­æ­¥éª¤"
              echo "should-continue=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # æƒ…å†µ 2: å¢é‡æ¨¡å¼ä¸‹æ— æ–°æ„å»ºï¼ˆæ­£å¸¸æƒ…å†µï¼šæ²¡æœ‰åŒ…æ›´æ–°ï¼‰
            if [ "$IS_SNAPSHOT" != "true" ] && [ "$HAS_NEW_BUILDS" != "true" ]; then
              echo "==> å¢é‡æ¨¡å¼ï¼šæ— åŒ…æ›´æ–°ï¼Œè·³è¿‡åç»­æ­¥éª¤"
              echo "should-continue=false" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            # æƒ…å†µ 3: æœ‰æ–°æ„å»ºæˆ–å¿«ç…§æ¨¡å¼ï¼Œä½†æ²¡æœ‰åŒ…æ–‡ä»¶ï¼ˆå¼‚å¸¸æƒ…å†µï¼‰
            echo "âŒ é”™è¯¯: æ²¡æœ‰æ‰¾åˆ°ä»»ä½•åŒ…æ–‡ä»¶ï¼"
            echo ""
            echo "è¯Šæ–­ä¿¡æ¯ï¼š"
            echo "  - æœ‰ç°æœ‰æ•°æ®: $HAS_EXISTING_DATA"
            echo "  - æœ‰æ–°æ„å»º: $HAS_NEW_BUILDS"
            echo "  - å¿«ç…§æ¨¡å¼: $IS_SNAPSHOT"
            echo ""
            echo "å¯èƒ½çš„åŸå› ï¼š"
            if [ "$HAS_NEW_BUILDS" = "true" ]; then
              echo "  1. âŒ artifacts ä¸‹è½½å¤±è´¥"
            fi
            if [ "$IS_SNAPSHOT" = "true" ]; then
              echo "  2. âŒ release ä¸‹è½½å¤±è´¥"
            fi
            echo "  3. âŒ æ„å»ºè¿‡ç¨‹å‡ºç°é—®é¢˜"
            exit 1
          fi
          
          echo "âœ“ æ‰¾åˆ° $pkg_count ä¸ªåŒ…æ–‡ä»¶"
          
          # å¿«ç…§æ¨¡å¼ï¼šæ— è®ºæ˜¯å¦æœ‰æ–°æ„å»ºï¼Œéƒ½è¦å‘å¸ƒ
          # å¢é‡æ¨¡å¼ï¼šåªæœ‰å½“æœ‰æ–°æ„å»ºæ—¶æ‰å‘å¸ƒ
          if [ "$IS_SNAPSHOT" = "true" ]; then
            echo "==> å¿«ç…§æ¨¡å¼ï¼šå°†åˆ›å»º release"
            echo "should-continue=true" >> $GITHUB_OUTPUT
          elif [ "$HAS_NEW_BUILDS" = "true" ]; then
            echo "==> å¢é‡æ¨¡å¼ï¼šæœ‰æ–°æ„å»ºï¼Œå°†æ›´æ–° release"
            echo "should-continue=true" >> $GITHUB_OUTPUT
          else
            echo "==> å¢é‡æ¨¡å¼ï¼šæ— æ–°æ„å»ºï¼Œè·³è¿‡ release æ›´æ–°"
            echo "should-continue=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Generate repository database
        if: steps.verify-packages.outputs.should-continue == 'true'
        env:
          OUTPUT_DIR: ./output
        run: |
          bash scripts/generate-repo.sh
      
      - name: Upload repository artifacts
        if: steps.verify-packages.outputs.should-continue == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: repository
          path: |
            output/*.pkg.tar.zst
            output/*.db*
            output/*.files*
          retention-days: 7

  # ===========================================================================
  # Job 4: å¢é‡æ¨¡å¼ - æ¸…ç†å’Œæœ€ç»ˆä¸€è‡´æ€§æ£€æŸ¥
  # ===========================================================================
  finalize-incremental:
    needs: [list-packages, build-packages]
    name: Finalize Incremental Update
    runs-on: ubuntu-latest
    if: |
      always() &&
      github.event_name != 'schedule' &&
      github.event.inputs.create_snapshot != 'true' &&
      needs.build-packages.result != 'cancelled' &&
      needs.list-packages.outputs.all-packages != '[]'
    container:
      image: archlinux:latest
    outputs:
      should-publish: ${{ steps.verify.outputs.should-continue }}
      new-package-count: ${{ steps.verify.outputs.new-package-count }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Install dependencies
        run: |
          pacman -Syu --noconfirm
          pacman -S --noconfirm pacman-contrib curl jq
      
      - name: Clean up all lock refs
        run: |
          echo "==> æ¸…ç†æ‰€æœ‰é—ç•™çš„é” refs"
          
          # è·å–æ‰€æœ‰ locks refs
          LOCKS=$(curl -s \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/git/matching-refs/locks/" \
            | jq -r '.[].ref // empty')
          
          if [ -z "$LOCKS" ]; then
            echo "  æ²¡æœ‰é—ç•™çš„é”"
          else
            echo "  å‘ç°é—ç•™é”:"
            echo "$LOCKS" | while read ref; do
              echo "    - $ref"
            done
            
            # åˆ é™¤æ‰€æœ‰é” refs
            echo "$LOCKS" | while read ref; do
              if [ -n "$ref" ]; then
                echo "  åˆ é™¤: $ref"
                HTTP_CODE=$(curl -s -w "%{http_code}" -o /dev/null -X DELETE \
                  -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                  -H "Accept: application/vnd.github.v3+json" \
                  "https://api.github.com/repos/${{ github.repository }}/git/$ref")
                
                if [ "$HTTP_CODE" = "204" ]; then
                  echo "    âœ“ åˆ é™¤æˆåŠŸ"
                elif [ "$HTTP_CODE" = "404" ]; then
                  echo "    âš  å·²ä¸å­˜åœ¨"
                else
                  echo "    âš  åˆ é™¤å¤±è´¥ (HTTP $HTTP_CODE)"
                fi
                sleep 0.5
              fi
            done
          fi
          
          echo "==> é”æ¸…ç†å®Œæˆ"
      
      - name: Clean old package versions before consistency check
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO_FULL: ${{ github.repository }}
          OUTPUT_DIR: /tmp/empty_for_scan
          RELEASE_TAG: latest
        run: |
          echo "==> æ¸…ç†æ—§åŒ…ç‰ˆæœ¬ä»¥ç¡®ä¿ä¸€è‡´æ€§æ£€æŸ¥å‡†ç¡®"
          # ç¡®ä¿ä½¿ç”¨æ‰«æé‡å¤ç‰ˆæœ¬æ¨¡å¼ï¼ˆOUTPUT_DIR ä¸ºç©ºï¼‰
          mkdir -p "$OUTPUT_DIR"
          bash scripts/clean-old-assets.sh
          
          echo "==> éªŒè¯æ¸…ç†ç»“æœ"
          DUPES=$(curl -s "https://api.github.com/repos/${{ github.repository }}/releases/tags/latest" | \
            jq -r '.assets[] | select(.name | endswith(".pkg.tar.zst")) | .name' | \
            sed 's/-[0-9].*\.pkg\.tar\.zst$//' | sort | uniq -d)
          
          if [ -n "$DUPES" ]; then
            echo "âš ï¸ è­¦å‘Šï¼šä»ç„¶å­˜åœ¨é‡å¤çš„åŒ…ï¼š"
            echo "$DUPES"
            echo "è¿™å¯èƒ½ä¼šå¯¼è‡´æ•°æ®åº“ä¸ä¸€è‡´"
          else
            echo "âœ“ æ— é‡å¤ç‰ˆæœ¬"
          fi
      
      - name: Check database consistency
        id: check-db
        run: |
          echo "==> æ£€æŸ¥æ•°æ®åº“ä¸€è‡´æ€§"
          
          # è·å– latest release ä¿¡æ¯
          LATEST_JSON=$(curl -s "https://api.github.com/repos/${{ github.repository }}/releases/tags/latest" || echo "{}")
          
          # æ£€æŸ¥ latest release æ˜¯å¦å­˜åœ¨
          if echo "$LATEST_JSON" | jq -e '.message == "Not Found"' > /dev/null 2>&1; then
            echo "  latest release ä¸å­˜åœ¨ï¼ˆé¦–æ¬¡æ„å»ºåçš„ç¬¬ä¸€æ¬¡å¢é‡æ›´æ–°ï¼‰"
            echo "needs_rebuild=false" >> $GITHUB_OUTPUT
            echo "has_packages=false" >> $GITHUB_ENV
            exit 0
          fi
          
          # ä¸‹è½½å½“å‰æ•°æ®åº“
          mkdir -p output
          echo "  ä¸‹è½½å½“å‰æ•°æ®åº“..."
          if ! curl -sfL "https://github.com/${{ github.repository }}/releases/download/latest/skorion.db.tar.gz" -o output/skorion.db.tar.gz; then
            echo "  âš ï¸ æ•°æ®åº“ä¸‹è½½å¤±è´¥æˆ–ä¸å­˜åœ¨ï¼Œéœ€è¦é‡å»º"
            echo "needs_rebuild=true" >> $GITHUB_OUTPUT
            echo "has_packages=true" >> $GITHUB_ENV
            exit 0
          fi
          
          # æå–æ•°æ®åº“ä¸­çš„åŒ…åˆ—è¡¨
          echo "  æå–æ•°æ®åº“åŒ…åˆ—è¡¨..."
          mkdir -p db_temp
          tar -xzf output/skorion.db.tar.gz -C db_temp 2>/dev/null || {
            echo "  âš ï¸ æ•°æ®åº“æ–‡ä»¶æŸåï¼Œéœ€è¦é‡å»º"
            echo "needs_rebuild=true" >> $GITHUB_OUTPUT
            echo "has_packages=true" >> $GITHUB_ENV
            rm -rf db_temp output/skorion.db.tar.gz
            exit 0
          }
          
          # ä» desc æ–‡ä»¶ä¸­æå–åŒ…åå’Œç‰ˆæœ¬
          db_packages=$(for desc_file in db_temp/*/desc; do
            if [ -f "$desc_file" ]; then
              pkg_name=""
              pkg_version=""
              pkg_arch=""
              while IFS= read -r line; do
                if [ "$line" = "%NAME%" ]; then
                  read -r pkg_name
                elif [ "$line" = "%VERSION%" ]; then
                  read -r pkg_version
                elif [ "$line" = "%ARCH%" ]; then
                  read -r pkg_arch
                fi
              done < "$desc_file"
              if [ -n "$pkg_name" ] && [ -n "$pkg_version" ] && [ -n "$pkg_arch" ]; then
                # è½¬æ¢ epoch æ ¼å¼: version:x -> version--x (æ–‡ä»¶ç³»ç»Ÿå‘½åè§„åˆ™)
                echo "${pkg_name}-${pkg_version/:/--}-${pkg_arch}.pkg.tar.zst"
              fi
            fi
          done | sort)
          
          rm -rf db_temp
          
          # è·å– latest release ä¸­çš„å®é™…åŒ…åˆ—è¡¨
          echo "  è·å– release åŒ…åˆ—è¡¨..."
          release_packages=$(echo "$LATEST_JSON" | jq -r '.assets[] | select(.name | endswith(".pkg.tar.zst")) | .name' | sort)
          
          # å¯¹æ¯”åŒ…åˆ—è¡¨
          db_count=$(echo -n "$db_packages" | grep -c . || echo 0)
          release_count=$(echo -n "$release_packages" | grep -c . || echo 0)
          
          echo "  æ•°æ®åº“åŒ…æ•°é‡: $db_count"
          echo "  Release åŒ…æ•°é‡: $release_count"
          
          if [ "$db_packages" = "$release_packages" ]; then
            echo "  âœ“ æ•°æ®åº“ä¸€è‡´ï¼Œæ— éœ€é‡å»º"
            echo "needs_rebuild=false" >> $GITHUB_OUTPUT
            echo "has_packages=false" >> $GITHUB_ENV
          else
            echo "  âš ï¸ æ•°æ®åº“ä¸ä¸€è‡´ï¼Œéœ€è¦é‡å»º"
            # æ˜¾ç¤ºå·®å¼‚ï¼ˆä»…å‰ 10 ä¸ªï¼‰
            if [ -n "$db_packages" ] && [ -n "$release_packages" ]; then
              echo "  æ•°æ®åº“ä¸­ä½† release ä¸­æ²¡æœ‰çš„åŒ…:"
              comm -23 <(printf '%s\n' "$db_packages") <(printf '%s\n' "$release_packages") | head -10 || true
              echo "  release ä¸­ä½†æ•°æ®åº“ä¸­æ²¡æœ‰çš„åŒ…:"
              comm -13 <(printf '%s\n' "$db_packages") <(printf '%s\n' "$release_packages") | head -10 || true
            fi
            echo "needs_rebuild=true" >> $GITHUB_OUTPUT
            echo "has_packages=true" >> $GITHUB_ENV
          fi
      
      - name: Download all packages from latest release
        if: steps.check-db.outputs.needs_rebuild == 'true'
        run: |
          echo "==> ä¸‹è½½æ‰€æœ‰åŒ…ä»¥é‡å»ºæ•°æ®åº“"
          
          # è·å– latest release ä¿¡æ¯
          LATEST_JSON=$(curl -s "https://api.github.com/repos/${{ github.repository }}/releases/tags/latest")
          
          # ä¸‹è½½æ‰€æœ‰åŒ…æ–‡ä»¶
          mkdir -p output
          echo "$LATEST_JSON" | jq -r '.assets[] | select(.name | endswith(".pkg.tar.zst")) | .browser_download_url' | while read url; do
            filename=$(basename "$url")
            echo "  ä¸‹è½½ $filename"
            curl -sL "$url" -o "output/$filename" || echo "    ä¸‹è½½å¤±è´¥"
          done
          
          # ç»Ÿè®¡ä¸‹è½½çš„åŒ…æ•°é‡
          pkg_count=$(ls -1 output/*.pkg.tar.zst 2>/dev/null | wc -l)
          echo "==> ä¸‹è½½å®Œæˆï¼Œå…± $pkg_count ä¸ªåŒ…"
      
      - name: Regenerate complete database
        if: steps.check-db.outputs.needs_rebuild == 'true'
        env:
          OUTPUT_DIR: ./output
        run: |
          echo "==> é‡æ–°ç”Ÿæˆå®Œæ•´æ•°æ®åº“"
          bash scripts/generate-repo.sh
      
      - name: Upload complete database and metadata
        if: steps.check-db.outputs.needs_rebuild == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: latest
          files: |
            output/*.db.tar.gz
            output/*.files.tar.gz
            output/*.db
            output/*.files
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Count successfully built packages
        id: count
        run: |
          # ç»Ÿè®¡æœ¬æ¬¡æ„å»ºçš„åŒ…æ•°é‡
          # é€šè¿‡æ£€æŸ¥ needs.list-packages çš„è¾“å‡º
          total_count=$(echo '${{ needs.list-packages.outputs.all-packages }}' | jq 'length')
          echo "new_packages=$total_count" >> $GITHUB_OUTPUT
          echo "==> æœ¬æ¬¡æ„å»º: $total_count ä¸ªåŒ…"
      
      - name: Verify finalize result
        id: verify
        run: |
          # åªè¦æœ‰åŒ…æ„å»ºäº†ï¼Œå°±ç®—æˆåŠŸï¼ˆå³ä½¿æ•°æ®åº“ä¸€è‡´æ— éœ€é‡å»ºï¼‰
          new_count=${{ steps.count.outputs.new_packages }}
          
          if [ "$new_count" -gt 0 ]; then
            echo "should-continue=true" >> $GITHUB_OUTPUT
            echo "new-package-count=$new_count" >> $GITHUB_OUTPUT
            
            if [ "${{ steps.check-db.outputs.needs_rebuild }}" = "true" ]; then
              echo "==> æœ€ç»ˆåŒ–å®Œæˆï¼ˆå·²é‡å»ºæ•°æ®åº“ï¼‰"
            else
              echo "==> æœ€ç»ˆåŒ–å®Œæˆï¼ˆæ•°æ®åº“ä¸€è‡´ï¼Œå·²ç”±å¢é‡æ›´æ–°ç»´æŠ¤ï¼‰"
            fi
          else
            echo "should-continue=false" >> $GITHUB_OUTPUT
            echo "new-package-count=0" >> $GITHUB_OUTPUT
            echo "==> æ— åŒ…éœ€è¦å‘å¸ƒ"
          fi

  # ===========================================================================
  # Job 5: å‘å¸ƒåˆ° GitHub Releases
  # ===========================================================================
  release:
    needs: [generate-snapshot, finalize-incremental]
    name: Publish Release
    runs-on: ubuntu-latest
    if: |
      always() &&
      github.event_name != 'pull_request' &&
      (
        (needs.generate-snapshot.result == 'success' && needs.generate-snapshot.outputs.should-publish == 'true') ||
        (needs.finalize-incremental.result == 'success' && needs.finalize-incremental.outputs.should-publish == 'true')
      )
    permissions:
      contents: write
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup version comparison tool
        run: |
          echo "ä½¿ç”¨ sort -V è¿›è¡Œç‰ˆæœ¬æ¯”è¾ƒï¼ˆå·²éªŒè¯å¯æ­£ç¡®å¤„ç†æ‰€æœ‰ç‰ˆæœ¬æ ¼å¼ï¼‰"
      
      - name: Check release mode
        id: mode
        run: |
          if [ "${{ needs.generate-snapshot.result }}" = "success" ]; then
            echo "mode=snapshot" >> $GITHUB_OUTPUT
            echo "==> å¿«ç…§æ¨¡å¼"
          else
            echo "mode=incremental" >> $GITHUB_OUTPUT
            echo "==> å¢é‡æ¨¡å¼"
          fi

      - name: Download repository artifacts (snapshot mode)
        if: steps.mode.outputs.mode == 'snapshot'
        uses: actions/download-artifact@v4
        with:
          name: repository
          path: output/
      
      - name: Get package count from latest release (incremental mode)
        if: steps.mode.outputs.mode == 'incremental'
        run: |
          echo "==> å¢é‡æ¨¡å¼ï¼šä» latest release ç»Ÿè®¡åŒ…æ•°é‡"
          mkdir -p output
          
          # ä» release assets ç»Ÿè®¡åŒ…æ•°é‡
          pkg_count=$(curl -s "https://api.github.com/repos/${{ github.repository }}/releases/tags/latest" | \
            jq '[.assets[] | select(.name | endswith(".pkg.tar.zst"))] | length')
          
          echo "$pkg_count" > /tmp/pkg_count.txt
          echo "==> ä»“åº“æ€»åŒ…æ•°: $pkg_count"
      
      - name: Generate release info
        id: release-info
        run: |
          echo "date=$(date +'%Y.%m.%d')" >> $GITHUB_OUTPUT
          echo "datetime=$(date +'%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_OUTPUT
          
          # ç»Ÿè®¡åŒ…æ•°é‡
          if [ "${{ steps.mode.outputs.mode }}" = "snapshot" ]; then
            # å¿«ç…§æ¨¡å¼ï¼šç»Ÿè®¡ output ç›®å½•ä¸­çš„åŒ…
            pkg_count=$(ls output/*.pkg.tar.zst 2>/dev/null | wc -l)
          else
            # å¢é‡æ¨¡å¼ï¼šä»ä¹‹å‰ç»Ÿè®¡çš„ç»“æœè¯»å–
            pkg_count=$(cat /tmp/pkg_count.txt 2>/dev/null || echo "0")
          fi
          echo "package_count=$pkg_count" >> $GITHUB_OUTPUT
          
          # ç»Ÿè®¡æœ¬æ¬¡æ„å»ºçš„æ–°åŒ…æ•°é‡ï¼ˆæ ¹æ®æ¨¡å¼ï¼‰
          if [ "${{ steps.mode.outputs.mode }}" = "snapshot" ]; then
            # å¿«ç…§æ¨¡å¼ï¼šç»Ÿè®¡ output ç›®å½•ä¸­çš„åŒ…
            new_pkg_count=$(ls output/*.pkg.tar.zst 2>/dev/null | wc -l)
          else
            # å¢é‡æ¨¡å¼ï¼šä» finalize-incremental çš„è¾“å‡ºè·å–
            new_pkg_count="${{ needs.finalize-incremental.outputs.new-package-count }}"
            # å¦‚æœä¸ºç©ºï¼Œè®¾ç½®ä¸º 0
            new_pkg_count="${new_pkg_count:-0}"
          fi
          echo "new_package_count=$new_pkg_count" >> $GITHUB_OUTPUT
      
      - name: Final cleanup - ensure no duplicates
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO_FULL: ${{ github.repository }}
          OUTPUT_DIR: /tmp/empty_for_final_scan
          RELEASE_TAG: latest
        run: |
          echo "==> æœ€ç»ˆæ¸…ç†ï¼šç¡®ä¿æ²¡æœ‰é‡å¤ç‰ˆæœ¬"
          # å¼ºåˆ¶ä½¿ç”¨æ‰«æé‡å¤ç‰ˆæœ¬æ¨¡å¼
          mkdir -p "$OUTPUT_DIR"
          bash scripts/clean-old-assets.sh
          
          echo "==> æœ€ç»ˆéªŒè¯"
          DUPES=$(curl -s "https://api.github.com/repos/${{ github.repository }}/releases/tags/latest" | \
            jq -r '.assets[] | select(.name | endswith(".pkg.tar.zst")) | .name' | \
            sed 's/-[0-9].*\.pkg\.tar\.zst$//' | sort | uniq -d)
          
          if [ -n "$DUPES" ]; then
            echo "âŒ é”™è¯¯ï¼šå‘å¸ƒå‰ä»å­˜åœ¨é‡å¤ç‰ˆæœ¬ï¼š"
            echo "$DUPES"
            echo "è¯·æ£€æŸ¥æ¸…ç†è„šæœ¬æˆ–æ‰‹åŠ¨æ¸…ç†"
            exit 1
          else
            echo "âœ“ éªŒè¯é€šè¿‡ï¼šæ— é‡å¤ç‰ˆæœ¬"
          fi
      
      - name: Update latest release (snapshot mode)
        if: steps.mode.outputs.mode == 'snapshot'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: latest
          name: Latest Build
          body: |
            **æœ€æ–°æ„å»ºçš„ SkorionOS åŒ…ä»“åº“**
            
            - æ„å»ºæ—¶é—´: ${{ steps.release-info.outputs.datetime }}
            - æäº¤: `${{ github.sha }}`
            - ä»“åº“æ€»åŒ…æ•°: ${{ steps.release-info.outputs.package_count }}
            - æœ¬æ¬¡æ›´æ–°: ${{ steps.release-info.outputs.new_package_count }} ä¸ªåŒ…
            
            ## ä½¿ç”¨æ–¹æ³•
            
            åœ¨ `/etc/pacman.conf` æ·»åŠ ï¼š
            ```ini
            [skorion]
            SigLevel = Optional TrustAll
            Server = https://github.com/${{ github.repository }}/releases/download/latest
            ```
            
            ç„¶åæ‰§è¡Œï¼š
            ```bash
            sudo pacman -Sy
            sudo pacman -S <package-name>
            ```
          files: output/*
          fail_on_unmatched_files: true
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Update latest release description (incremental mode)
        if: steps.mode.outputs.mode == 'incremental'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: latest
          name: Latest Build
          body: |
            **æœ€æ–°æ„å»ºçš„ SkorionOS åŒ…ä»“åº“**
            
            - æ„å»ºæ—¶é—´: ${{ steps.release-info.outputs.datetime }}
            - æäº¤: `${{ github.sha }}`
            - ä»“åº“æ€»åŒ…æ•°: ${{ steps.release-info.outputs.package_count }}
            - æœ¬æ¬¡æ›´æ–°: ${{ steps.release-info.outputs.new_package_count }} ä¸ªåŒ…
            
            ## ä½¿ç”¨æ–¹æ³•
            
            åœ¨ `/etc/pacman.conf` æ·»åŠ ï¼š
            ```ini
            [skorion]
            SigLevel = Optional TrustAll
            Server = https://github.com/${{ github.repository }}/releases/download/latest
            ```
            
            ç„¶åæ‰§è¡Œï¼š
            ```bash
            sudo pacman -Sy
            sudo pacman -S <package-name>
            ```
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Create dated snapshot
        if: github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && inputs.create_snapshot)
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ steps.release-info.outputs.date }}
          name: Snapshot - ${{ steps.release-info.outputs.date }}
          body: |
            **å½’æ¡£å¿«ç…§**
            
            - æ„å»ºæ—¶é—´: ${{ steps.release-info.outputs.datetime }}
            - æäº¤: `${{ github.sha }}`
            - ä»“åº“æ€»åŒ…æ•°: ${{ steps.release-info.outputs.package_count }}
            
            æ­¤ç‰ˆæœ¬ä¸ºè‡ªåŠ¨åˆ›å»ºçš„å¿«ç…§ï¼Œå¯ç”¨äºå›æ»šåˆ°ç‰¹å®šæ—¥æœŸçš„åŒ…é›†åˆã€‚
            
            ## ä½¿ç”¨æ–¹æ³•
            
            åœ¨ `/etc/pacman.conf` æ·»åŠ ï¼š
            ```ini
            [skorion]
            SigLevel = Optional TrustAll
            Server = https://github.com/${{ github.repository }}/releases/download/${{ steps.release-info.outputs.date }}
            ```
          files: output/*
          fail_on_unmatched_files: true
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
